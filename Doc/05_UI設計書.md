# UI設計書

## 1. 概要

### 1.1 目的
本書は、Traincrew発車メロディー連動システムのユーザーインターフェース設計を詳細に定義する。

### 1.2 参照ドキュメント
- 要件定義書.md
- 01_システムアーキテクチャ設計書.md
- 03_インターフェース設計書.md

### 1.3 UI設計方針

| 項目 | 方針 |
|-----|------|
| デザイン | シンプルで直感的な操作性を重視 |
| カラー | システムデフォルト、必要に応じて視認性の高い色を使用 |
| フォント | システムデフォルトフォント（メイリオ等） |
| レスポンシブ | 固定サイズウィンドウ（350x700px） |
| アクセシビリティ | 大きなボタン、明確な状態表示 |

## 2. メインウィンドウ

### 2.1 ウィンドウ仕様

| 項目 | 仕様                                           |
|-----|----------------------------------------------|
| ウィンドウタイトル | "Traincrew depMelody"                        |
| サイズ | 幅: 350px, 高さ: 700px                          |
| リサイズ可能 | 可能                                           |
| 最小化 | 可能                                           |
| 最大化 | 不可                                           |
| 最前面表示 | 将来的にユーザー設定可能（初期値: false）                     |
| 背景色 | システムデフォルト                                    |
| 起動位置 | 画面中央（`WindowStartupLocation="CenterScreen"`） |

### 2.2 レイアウト構成

```
┌─────────────────────────────────────┐
│  Traincrew depMelody                │ ← タイトルバー
├─────────────────────────────────────┤
│                                     │
│                                     │
│                                     │
│                ON                   │ ← ONボタン
│                                     │   (画面上半分全体)
│                                     │   FontSize: 72pt
│                                     │   背景: 黒、前景: 白
│                                     │
├─────────────────────────────────────┤
│                                     │
│                                     │
│                                     │
│               OFF                   │ ← OFFボタン
│                                     │   (画面下半分全体)
│                                     │   FontSize: 72pt
│                                     │   背景: 赤、前景: 白
│                                     │
└─────────────────────────────────────┘

※ 開発者モード表示エリアは将来機能として追加予定
```

### 2.3 XAML構成イメージ

```xml
<Window x:Class="Traincrew_depMelody.Presentation.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Traincrew depMelody"
        Width="350" Height="700"
        WindowStartupLocation="CenterScreen"
        ResizeMode="NoResize">
     <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <Button Grid.Row="0" Name="ON" Content="ON" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Background="Black" Foreground="White" FontSize="72" Click="ButtonPressed" IsEnabled="False"/>
        <Button Grid.Row="1" Name="OFF" Content="OFF" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Background="Red" Foreground="White"  FontSize="72" Click="ButtonPressed" IsEnabled="False"/>
    </Grid>
</Window>
```

## 3. UI要素詳細

### 3.1 ONボタン

#### 3.1.1 基本仕様

| 項目 | 仕様 |
|-----|------|
| コントロール名 | `ON` |
| 表示テキスト | "ON" |
| サイズ | ウィンドウ上半分全体（Stretch） |
| フォントサイズ | 72pt |
| 背景色（有効時） | 黒（Black） |
| 前景色 | 白（White） |
| 配置 | Grid.Row="0"、全体に引き伸ばし |

#### 3.1.2 状態別の表示

| 状態 | 有効/無効 | 背景色 | 前景色 | ツールチップ |
|-----|---------|--------|--------|-------------|
| 乗務中・駅内・自動オフ | 有効 | 黒（Black） | 白（White） | "メロディーを開始" |
| 自動モードON | 無効 | グレー | ダークグレー | "自動モード有効中" |
| 乗務中以外（Pause中含む） | 無効 | グレー | ダークグレー | "乗務中のみ使用可能" |
| 駅外 | 無効 | グレー | ダークグレー | "駅に在線していません" |

#### 3.1.3 有効化条件

ONボタンは以下の**すべての条件**を満たす場合のみ有効化される：

1. **プレイ中**: `GameState.Screen == GameScreen.Playing`
2. **駅に在線**: `GameState.IsAtStation == true`
3. **自動モードオフ**: `AutoModeService.IsEnabled == false`

※ メロディーの再生状態に関わらず、上記3条件を満たせば有効化される

#### 3.1.4 イベント

| イベント | ハンドラ | 処理内容 |
|---------|---------|---------|
| Click | `OnButton_Click` | ONボタン押下時の処理（`MelodyControlService.StartMelodyAsync()` を呼び出し） |

### 3.2 OFFボタン

#### 3.2.1 基本仕様

| 項目 | 仕様 |
|-----|------|
| コントロール名 | `OFF` |
| 表示テキスト | "OFF" |
| サイズ | ウィンドウ下半分全体（Stretch） |
| フォントサイズ | 72pt |
| 背景色（有効時） | 赤（Red） |
| 前景色 | 白（White） |
| 配置 | Grid.Row="1"、全体に引き伸ばし |

#### 3.2.2 状態別の表示

| 状態 | 有効/無効 | 背景色 | 前景色 | ツールチップ |
|-----|---------|--------|--------|-------------|
| 乗務中・駅内・自動オフ | 有効 | 赤（Red） | 白（White） | "メロディーを停止" |
| 自動モードON | 無効 | グレー | ダークグレー | "自動モード有効中" |
| 乗務中以外（Pause中含む） | 無効 | グレー | ダークグレー | "乗務中のみ使用可能" |
| 駅外 | 無効 | グレー | ダークグレー | "駅に在線していません" |

#### 3.2.3 有効化条件

OFFボタンは以下の**すべての条件**を満たす場合のみ有効化される：

1. **プレイ中**: `GameState.Screen == GameScreen.Playing`
2. **駅に在線**: `GameState.IsAtStation == true`
3. **自動モードオフ**: `AutoModeService.IsEnabled == false`

※ メロディーの再生状態に関わらず、上記3条件を満たせば有効化される

#### 3.2.4 イベント

| イベント | ハンドラ | 処理内容 |
|---------|---------|---------|
| Click | `OffButton_Click` | OFFボタン押下時の処理（`MelodyControlService.StopMelodyAsync()` を呼び出し） |

### 3.3 開発者モードパネル（将来機能）

#### 3.3.1 基本仕様

| 項目 | 仕様 |
|-----|------|
| コントロール名 | `DeveloperPanel` |
| 初期表示 | 非表示（`Visibility="Collapsed"`） |
| 表示条件 | `AppConfiguration.DeveloperMode = true` |
| ボーダー | 1px グレー |
| パディング | 10px |
| マージン | 上部20px |

#### 3.3.2 表示項目

| 項目 | コントロール名 | 表示内容 | 更新タイミング |
|-----|---------------|---------|---------------|
| 駅名 | `StationNameText` | "駅名: 館浜駅" | メロディー状態変化時 |
| 番線 | `TrackNumberText` | "番線: 1番線" | メロディー状態変化時 |
| 状態 | `MelodyStateText` | "状態: 再生中" | メロディー状態変化時 |
| 自動モード | `AutoModeText` | "自動: ON" | 自動モード状態変化時 |
| 軌道回路 | `CircuitIdText` | "軌道回路: TC_001" | ゲーム状態変化時 |

## 4. ボタン状態遷移

### 4.1 状態遷移図

```
初期状態（駅外）
  ├─ ONボタン: 無効
  └─ OFFボタン: 無効
           ↓
      （駅に在線）
           ↓
駅内・停止中
  ├─ ONボタン: 有効
  └─ OFFボタン: 無効
           ↓
      （ONクリック）
           ↓
メロディー再生中
  ├─ ONボタン: 無効
  └─ OFFボタン: 有効
           ↓
      （OFFクリック）
           ↓
駅内・停止中（再度）
  ├─ ONボタン: 有効
  └─ OFFボタン: 無効
           ↓
      （駅から離脱）
           ↓
初期状態（駅外）
```

### 4.2 状態遷移表

| 現在の状態 | イベント | 次の状態 | ONボタン | OFFボタン |
|-----------|---------|---------|---------|----------|
| 駅外 | 駅に在線 | 駅内・停止中 | 有効 | 無効 |
| 駅内・停止中 | ONクリック | メロディー再生中 | 無効 | 有効 |
| メロディー再生中 | OFFクリック | 駅内・停止中 | 有効 | 無効 |
| メロディー再生中 | 駅から離脱 | 駅外 | 無効 | 無効 |
| 駅内・停止中 | 駅から離脱 | 駅外 | 無効 | 無効 |
| 任意の状態 | 一時停止 | 一時停止中 | 無効 | 無効 |
| 一時停止中 | 一時停止解除 | 元の状態 | 元の状態に応じる | 元の状態に応じる |
| 任意の状態 | 自動モードON | 自動モード中 | 無効 | 無効 |
| 自動モード中 | 自動モードOFF | 元の状態 | 元の状態に応じる | 元の状態に応じる |

## 5. エラー表示

### 5.1 MessageBox表示

#### 5.1.1 エラーメッセージ

| エラー種別 | タイトル | メッセージ | アイコン | ボタン |
|-----------|---------|-----------|---------|--------|
| 音声ファイル未存在 | "エラー" | "メロディーファイルが見つかりません" | Error | OK |
| 一般エラー | "エラー" | "エラー: {例外メッセージ}" | Error | OK |

#### 5.1.2 表示例

```csharp
MessageBox.Show(
    "メロディーファイルが見つかりません",
    "エラー",
    MessageBoxButton.OK,
    MessageBoxImage.Error);
```

### 5.2 ステータスバー（将来機能）

ウィンドウ下部にステータスバーを追加し、簡易的な状態表示を行う。

| 状態 | 表示テキスト |
|-----|------------|
| 正常 | "準備完了" |
| メロディー再生中 | "再生中: 館浜駅 1番線" |
| エラー | "エラー: 音声ファイルが見つかりません" |

## 6. スタイル定義

### 6.1 カラーパレット

| 要素 | カラー | 用途 |
|-----|--------|------|
| ONボタン背景（有効時） | #000000（Black / 黒） | ONボタン背景 |
| OFFボタン背景（有効時） | #FF0000（Red / 赤） | OFFボタン背景 |
| 無効状態背景 | #CCCCCC（グレー） | 無効ボタン背景 |
| ボタンテキスト（有効時） | #FFFFFF（White / 白） | 有効ボタンテキスト |
| 無効テキスト | #666666（ダークグレー） | 無効ボタンテキスト |
| ボーダー | #999999（グレー） | 開発者パネルボーダー（将来） |

### 6.2 WPFスタイル定義

現在の実装では、各ボタンに直接属性を設定している（インラインスタイル）。

**ONボタン**:
- Background: Black
- Foreground: White
- FontSize: 72

**OFFボタン**:
- Background: Red
- Foreground: White
- FontSize: 72

**無効状態の制御（将来的にトリガーで実装）**:
```xml
<Window.Resources>
    <!-- ONボタンスタイル -->
    <Style x:Key="OnButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="Black"/>
        <Setter Property="Foreground" Value="White"/>
        <Setter Property="FontSize" Value="72"/>
        <Setter Property="BorderThickness" Value="0"/>
        <Style.Triggers>
            <Trigger Property="IsEnabled" Value="False">
                <Setter Property="Background" Value="#CCCCCC"/>
                <Setter Property="Foreground" Value="#666666"/>
            </Trigger>
        </Style.Triggers>
    </Style>

    <!-- OFFボタンスタイル -->
    <Style x:Key="OffButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="Red"/>
        <Setter Property="Foreground" Value="White"/>
        <Setter Property="FontSize" Value="72"/>
        <Setter Property="BorderThickness" Value="0"/>
        <Style.Triggers>
            <Trigger Property="IsEnabled" Value="False">
                <Setter Property="Background" Value="#CCCCCC"/>
                <Setter Property="Foreground" Value="#666666"/>
            </Trigger>
        </Style.Triggers>
    </Style>
</Window.Resources>
```

## 7. アニメーション（将来機能）

### 7.1 ボタンクリックアニメーション

ボタンクリック時に軽微なスケールアニメーションを適用。

```xml
<Button.Triggers>
    <EventTrigger RoutedEvent="Button.Click">
        <BeginStoryboard>
            <Storyboard>
                <DoubleAnimation Storyboard.TargetProperty="RenderTransform.ScaleX"
                                 From="1.0" To="0.95" Duration="0:0:0.1" AutoReverse="True"/>
                <DoubleAnimation Storyboard.TargetProperty="RenderTransform.ScaleY"
                                 From="1.0" To="0.95" Duration="0:0:0.1" AutoReverse="True"/>
            </Storyboard>
        </BeginStoryboard>
    </EventTrigger>
</Button.Triggers>
```

### 7.2 状態遷移アニメーション

ボタンの有効/無効状態が変化する際のフェードアニメーション。

## 8. アクセシビリティ

### 8.1 キーボードナビゲーション

#### 8.1.1 キーボード操作による制御（将来機能）

キーボードを使ってメロディーのON/OFF操作を行う機能。グローバルホットキーとして実装され、他アプリにフォーカスがあっても動作する。

##### 8.1.1.1 操作モード概要

要件定義書 6.3節に基づき、4つの操作モードを提供する。ユーザーは設定画面でモードを選択可能。

| モード | モード名 | 説明 | 用途 |
|-------|---------|------|------|
| モード1 | キーボード操作なし | キーボード操作を一切行わない | マウス操作のみで使用する場合 |
| モード2 | 2キー独立モード | 2つのキーでON/OFFを独立制御 | 左手でON、右手でOFFなど明確に使い分けたい場合 |
| モード3 | プッシュトゥトーク型 | キー押下中のみON、キーを離すとOFF | 実機の発車メロディースイッチに近い操作感 |
| モード4 | トグル型 | 同一キーの押下でON/OFF切替 | シンプルな1キー操作を好む場合 |

##### 8.1.1.2 モード1: キーボード操作なし

**動作**:
- キーボード操作機能を無効化
- UIボタンのみでメロディー制御を行う
- グローバルホットキーは登録されない

**設定項目**:
- なし

**実装時の注意**:
- このモードが選択されている場合、グローバルホットキーの登録処理をスキップ
- 他のモードからこのモードに切り替えた際は、既存のホットキー登録を解除

##### 8.1.1.3 モード2: 2キー独立モード

**動作**:
- ONキー押下 → メロディー開始（ONボタンクリックと同等）
- OFFキー押下 → メロディー停止（OFFボタンクリックと同等）
- 各キーの動作は完全に独立

**設定項目**:
- `OnKey`: メロディー開始用のキー（デフォルト: `NumPad1` または `D1`）
- `OffKey`: メロディー停止用のキー（デフォルト: `NumPad2` または `D2`）

**状態遷移**:
```
[停止中] --[ONキー押下]--> [再生中]
[再生中] --[OFFキー押下]--> [停止中]
[再生中] --[ONキー押下]--> (無視・何もしない)
[停止中] --[OFFキー押下]--> (無視・何もしない)
```

**ボタン有効性との連動**:
- ONキー: `OnButton.IsEnabled == true` の場合のみ動作
- OFFキー: `OffButton.IsEnabled == true` の場合のみ動作
- 無効時のキー入力は無視され、何も起こらない

**実装イメージ**:
```csharp
// グローバルホットキーハンドラ（Mode2）
private void OnGlobalHotKeyPressed(int hotkeyId)
{
    if (hotkeyId == _onKeyHotkeyId)
    {
        // ONキーが押された
        Dispatcher.Invoke(() =>
        {
            if (OnButton.IsEnabled)
            {
                OnButton_Click(this, new RoutedEventArgs());
            }
        });
    }
    else if (hotkeyId == _offKeyHotkeyId)
    {
        // OFFキーが押された
        Dispatcher.Invoke(() =>
        {
            if (OffButton.IsEnabled)
            {
                OffButton_Click(this, new RoutedEventArgs());
            }
        });
    }
}
```

##### 8.1.1.4 モード3: プッシュトゥトーク型

**動作**:
- 指定キーを**押している間**メロディーが再生される
- キーを**離す**とメロディーが停止し、ドア閉め案内が再生される
- 実機の発車メロディースイッチの操作感を再現

**設定項目**:
- `TriggerKey`: メロディー制御用のキー（デフォルト: `Space` または `NumPad0`）

**状態遷移**:
```
[停止中] --[キー押下]--> [再生中]
[再生中] --[キー離す]--> [停止中 + ドア閉め案内再生]
```

**ボタン有効性との連動**:
- キー押下時: `OnButton.IsEnabled == true` の場合のみメロディー開始
- キー離し時: `OffButton.IsEnabled == true` の場合のみメロディー停止
- どちらかのボタンが無効な場合、そのタイミングでの操作は無視

**リピート防止**:
- キーを押し続けた際のOSのキーリピート機能による複数イベント発火を防止
- 状態管理により、既に再生中の場合は追加のON処理を実行しない

**実装イメージ**:
```csharp
private bool _isKeyCurrentlyPressed = false;

// グローバルホットキーハンドラ（Mode3 - KeyDown）
private void OnGlobalHotKeyDown(int hotkeyId)
{
    if (_isKeyCurrentlyPressed) return; // リピート防止

    Dispatcher.Invoke(() =>
    {
        if (OnButton.IsEnabled)
        {
            _isKeyCurrentlyPressed = true;
            OnButton_Click(this, new RoutedEventArgs());
        }
    });
}

// グローバルホットキーハンドラ（Mode3 - KeyUp）
private void OnGlobalHotKeyUp(int hotkeyId)
{
    if (!_isKeyCurrentlyPressed) return;

    Dispatcher.Invoke(() =>
    {
        if (OffButton.IsEnabled)
        {
            _isKeyCurrentlyPressed = false;
            OffButton_Click(this, new RoutedEventArgs());
        }
    });
}
```

**注意事項**:
- グローバルホットキーのKeyUpイベント検出には、低レベルキーボードフック（`SetWindowsHookEx`）の使用が必要
- Win32 API の `RegisterHotKey` だけではKeyUp検出ができないため、別途実装が必要

##### 8.1.1.5 モード4: トグル型

**動作**:
- 指定キーの押下ごとにON/OFF状態をトグル（切り替え）
- 停止中にキー押下 → メロディー開始
- 再生中にキー押下 → メロディー停止＆ドア閉め案内再生

**設定項目**:
- `ToggleKey`: メロディートグル用のキー（デフォルト: `NumPad5` または `T`）

**状態遷移**:
```
[停止中] --[キー押下]--> [再生中]
[再生中] --[キー押下]--> [停止中 + ドア閉め案内再生]
```

**ボタン有効性との連動**:
- 停止中にキー押下: `OnButton.IsEnabled == true` の場合のみメロディー開始
- 再生中にキー押下: `OffButton.IsEnabled == true` の場合のみメロディー停止
- 両ボタンが無効な場合（駅外、自動モード中など）はキー入力を無視

**内部状態管理**:
- メロディーの再生状態を内部で保持（`_isMelodyPlaying`）
- キー押下時に状態を確認し、適切な動作（ON/OFF）を判定

**実装イメージ**:
```csharp
private bool _isMelodyPlaying = false;

// グローバルホットキーハンドラ（Mode4）
private void OnGlobalHotKeyPressed(int hotkeyId)
{
    Dispatcher.Invoke(() =>
    {
        if (!_isMelodyPlaying)
        {
            // 停止中 → ON処理
            if (OnButton.IsEnabled)
            {
                _isMelodyPlaying = true;
                OnButton_Click(this, new RoutedEventArgs());
            }
        }
        else
        {
            // 再生中 → OFF処理
            if (OffButton.IsEnabled)
            {
                _isMelodyPlaying = false;
                OffButton_Click(this, new RoutedEventArgs());
            }
        }
    });
}
```

**状態同期**:
- UIボタンでの操作時にも `_isMelodyPlaying` を同期して更新
- 自動モードによるメロディー制御時も状態を同期

##### 8.1.1.6 キーバインド設定UI

**設定画面での操作フロー**:
1. ユーザーが設定ウィンドウを開く
2. 「キーボード操作」タブを選択
3. 操作モード（モード1〜4）をドロップダウンから選択
4. 選択したモードに応じて、キー設定UIが表示される
   - モード1: キー設定UI非表示
   - モード2: 「ONキー」「OFFキー」の2つの設定欄を表示
   - モード3: 「トリガーキー」の1つの設定欄を表示
   - モード4: 「トグルキー」の1つの設定欄を表示
5. 各設定欄のボタンをクリック
6. 「キーを押してください...」という待機状態になる
7. ユーザーが任意のキーを押す
8. 押されたキーが設定欄に表示され、登録される

**キー設定UIのイメージ**:
```
┌────────────────────────────────────┐
│ キーボード操作設定                   │
├────────────────────────────────────┤
│ 操作モード: [モード2: 2キー独立▼]    │
├────────────────────────────────────┤
│ ONキー:  [ NumPad1 ] [変更]         │
│ OFFキー: [ NumPad2 ] [変更]         │
├────────────────────────────────────┤
│              [保存] [キャンセル]      │
└────────────────────────────────────┘
```

**キー入力検出の実装**:
```csharp
// 設定画面でのキー入力待機
private void OnKeyBindingButton_Click(object sender, RoutedEventArgs e)
{
    var button = sender as Button;
    button.Content = "キーを押してください...";
    button.IsEnabled = false;

    // KeyDownイベントで次のキー入力を待機
    _isWaitingForKeyInput = true;
    _currentKeyBindingButton = button;
}

private void SettingsWindow_KeyDown(object sender, KeyEventArgs e)
{
    if (!_isWaitingForKeyInput) return;

    // 押されたキーを取得
    var key = e.Key;

    // キーを設定
    _currentKeyBindingButton.Content = key.ToString();
    _currentKeyBindingButton.IsEnabled = true;
    _isWaitingForKeyInput = false;

    // 設定を保存（仮）
    // TODO: 実際には設定オブジェクトに格納し、「保存」ボタンで永続化
}
```

##### 8.1.1.7 グローバルホットキーの実装

**実装技術**:
- Win32 API の `RegisterHotKey` / `UnregisterHotKey` を使用
- モード3（プッシュトゥトーク型）のKeyUp検出には `SetWindowsHookEx` を併用

**ホットキー登録処理**:
```csharp
[DllImport("user32.dll")]
private static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, uint vk);

[DllImport("user32.dll")]
private static extern bool UnregisterHotKey(IntPtr hWnd, int id);

private const int HOTKEY_ID_ON = 1;
private const int HOTKEY_ID_OFF = 2;

private void RegisterGlobalHotKeys()
{
    var windowHandle = new WindowInteropHelper(this).Handle;
    var source = HwndSource.FromHwnd(windowHandle);
    source.AddHook(HwndHook);

    // モードに応じたホットキー登録
    if (_keyboardMode == KeyboardMode.Mode2)
    {
        RegisterHotKey(windowHandle, HOTKEY_ID_ON, 0, (uint)KeyInterop.VirtualKeyFromKey(_onKey));
        RegisterHotKey(windowHandle, HOTKEY_ID_OFF, 0, (uint)KeyInterop.VirtualKeyFromKey(_offKey));
    }
    // 以下、他モードの登録処理...
}

private IntPtr HwndHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)
{
    const int WM_HOTKEY = 0x0312;
    if (msg == WM_HOTKEY)
    {
        OnGlobalHotKeyPressed(wParam.ToInt32());
        handled = true;
    }
    return IntPtr.Zero;
}
```

##### 8.1.1.8 自動モード時の動作

**全モード共通**:
- 自動モードが有効（`AutoModeService.IsEnabled == true`）の場合、すべてのキーボード入力を無視
- グローバルホットキー自体は登録されたままだが、ハンドラ内で自動モード判定を行い、早期リターン

**実装イメージ**:
```csharp
private void OnGlobalHotKeyPressed(int hotkeyId)
{
    // 自動モード中はキーボード操作を無視
    if (_autoModeService.IsEnabled) return;

    // 通常のホットキー処理...
}
```

##### 8.1.1.9 設定の永続化

**保存先**:
- `appsettings.json` または専用の設定ファイル（`keyboard_settings.json`）

**設定項目**:
```json
{
  "KeyboardSettings": {
    "Mode": 2,
    "Mode2": {
      "OnKey": "NumPad1",
      "OffKey": "NumPad2"
    },
    "Mode3": {
      "TriggerKey": "Space"
    },
    "Mode4": {
      "ToggleKey": "T"
    }
  }
}
```

**読み込みタイミング**:
- アプリケーション起動時に設定を読み込み
- 設定ウィンドウで変更後、「保存」ボタン押下時に設定ファイルに書き込み
- 書き込み後、即座にホットキーの再登録を実施

#### 8.1.2 WPF標準のキーボードナビゲーション

グローバルホットキーとは別に、ウィンドウにフォーカスがある場合の標準的なキーボードナビゲーションも提供する。

| キー | 動作 |
|-----|------|
| Tab | 次のコントロールにフォーカス移動 |
| Shift+Tab | 前のコントロールにフォーカス移動 |
| Enter / Space | フォーカス中のボタンをクリック |
| Alt+F4 | ウィンドウを閉じる |

**注意**:
- WPF標準ナビゲーションは、ウィンドウがフォーカスを持っている場合のみ有効
- Traincrewゲームプレイ中は通常ゲームウィンドウにフォーカスがあるため、グローバルホットキーの使用を推奨

### 8.2 ツールチップ

各ボタンに状態に応じたツールチップを表示し、操作ガイダンスを提供。

### 8.3 スクリーンリーダー対応

`AutomationProperties` を設定し、スクリーンリーダーに適切な情報を提供。

```xml
<Button Name="ON"
        AutomationProperties.Name="メロディー開始ボタン"
        AutomationProperties.HelpText="発車メロディーの再生を開始します"/>
```

## 9. 将来のUI拡張

### 9.1 設定ウィンドウ

メニューバーに「設定」メニューを追加し、設定ウィンドウを開く。

**設定項目**:
- FFmpegパス
- 音声ベースディレクトリ
- 自動モード設定
- キーボード操作設定
- 開発者モード有効化

### 9.2 メニューバー

ウィンドウ上部にメニューバーを追加。

| メニュー | サブメニュー | 動作 |
|---------|------------|------|
| ファイル | 終了 | アプリケーション終了 |
| 設定 | 設定を開く | 設定ウィンドウ表示 |
| ヘルプ | バージョン情報 | バージョン情報ダイアログ表示 |

### 9.3 通知エリア（トレイアイコン）

タスクトレイにアイコンを表示し、最小化時にトレイに格納。

| 機能 | 動作 |
|-----|------|
| トレイアイコン右クリック | コンテキストメニュー表示 |
| コンテキストメニュー | 「開く」「終了」 |
| アイコンダブルクリック | ウィンドウを復元 |

## 10. まとめ

本UI設計書では、以下を定義した：

1. **メインウィンドウ**: 極めてシンプルな2ボタンフルスクリーンレイアウト
   - ONボタン: 画面上半分全体、黒背景・白文字、フォントサイズ72pt
   - OFFボタン: 画面下半分全体、赤背景・白文字、フォントサイズ72pt
2. **ボタン仕様**: 状態に応じた有効/無効制御と視覚的フィードバック
3. **エラー表示**: MessageBoxによる明確なエラー通知
4. **スタイル定義**: 視認性を最大化したシンプルなカラーリング（黒・赤・白）
5. **アクセシビリティ**: キーボードナビゲーション・ツールチップ対応

大きなボタンと明確な色分けにより、ゲームプレイ中でも操作しやすいUIを提供する。
将来的には開発者モードや設定ウィンドウなどの拡張にも対応可能な設計となっている。
