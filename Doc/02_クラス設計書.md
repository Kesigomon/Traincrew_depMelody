# クラス設計書

## 1. 概要

### 1.1 目的
本書は、Traincrew発車メロディー連動システムの詳細なクラス設計を定義する。

### 1.2 参照ドキュメント
- 要件定義書.md
- 01_システムアーキテクチャ設計書.md

## 2. クラス一覧

### 2.1 レイヤー別クラス一覧

| レイヤー | 名前空間 | クラス名 | 種別 | 概要 |
|---------|---------|---------|------|------|
| Presentation | Traincrew_depMelody.Presentation.Views | MainWindow | Class | メインウィンドウ |
| Application | Traincrew_depMelody.Application.Services | MelodyControlService | Class | メロディー制御サービス |
| Application | Traincrew_depMelody.Application.Services | AutoModeService | Class | 自動モードサービス |
| Application | Traincrew_depMelody.Application.Services | AudioPlaybackService | Class | 音声再生統合サービス |
| Domain | Traincrew_depMelody.Domain.Models | TrackInfo | Class | 駅・番線情報モデル |
| Domain | Traincrew_depMelody.Domain.Models | GameState | Class | ゲーム状態モデル |
| Domain | Traincrew_depMelody.Domain.Models | TrainState | Class | 列車状態モデル |
| Domain | Traincrew_depMelody.Domain.Models | SignalInfo | Class | 信号情報モデル |
| Domain | Traincrew_depMelody.Domain.Models | MelodyState | Class | メロディー状態モデル |
| Domain | Traincrew_depMelody.Domain.Models | AutoModeConfig | Class | 自動モード設定モデル |
| Domain | Traincrew_depMelody.Domain.Models | AppConfiguration | Class | アプリ設定モデル |
| Domain | Traincrew_depMelody.Domain.Models | AudioProfile | Class | 音声プロファイルモデル |
| Domain | Traincrew_depMelody.Domain.Interfaces.Repositories | IAudioProfileRepository | Interface | 音声プロファイルリポジトリIF |
| Infrastructure | Traincrew_depMelody.Infrastructure.Repositories | AudioProfileRepository | Class | 音声プロファイルリポジトリ |
| Domain | Traincrew_depMelody.Domain.Interfaces.Repositories | ITrackRepository | Interface | 駅・番線リポジトリIF |
| Domain | Traincrew_depMelody.Domain.Interfaces.Services | ITraincrewGameService | Interface | ゲーム連携サービスIF |
| Domain | Traincrew_depMelody.Domain.Interfaces.Services | IFFmpegService | Interface | FFmpegサービスIF |
| Domain | Traincrew_depMelody.Domain.Interfaces.Services | IAudioPlayerService | Interface | 音声再生サービスIF |
| Domain | Traincrew_depMelody.Domain.Interfaces | IMelodyControlService | Interface | メロディー制御サービスIF |
| Domain | Traincrew_depMelody.Domain.Interfaces | IAutoModeService | Interface | 自動モードサービスIF |
| Domain | Traincrew_depMelody.Domain.Interfaces | IAudioPlaybackService | Interface | 音声再生統合サービスIF |
| Infrastructure | Traincrew_depMelody.Infrastructure.Repositories | TrackRepository | Class | 駅・番線リポジトリ |
| Infrastructure | Traincrew_depMelody.Infrastructure.ExternalServices | TraincrewGameService | Class | ゲーム連携サービス |
| Infrastructure | Traincrew_depMelody.Infrastructure.ExternalServices | FFmpegService | Class | FFmpegサービス |
| Infrastructure | Traincrew_depMelody.Infrastructure.AudioServices | MediaPlayerService | Class | メディアプレーヤーサービス |

## 3. Domain Layer（ドメイン層）

### 3.1 Models

#### 3.1.1 TrackInfo

**責務**: 駅と番線の情報を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// 駅・番線情報
/// </summary>
public class TrackInfo
{
    /// <summary>
    /// 駅名
    /// </summary>
    public string StationName { get; init; }

    /// <summary>
    /// 番線（例: "1", "2"）
    /// </summary>
    public string TrackNumber { get; init; }

    /// <summary>
    /// この番線に対応する軌道回路IDのリスト
    /// </summary>
    public List<string> CircuitIds { get; init; }

    /// <summary>
    /// コンストラクタ
    /// </summary>
    public TrackInfo(string stationName, string trackNumber, List<string> circuitIds)
    {
        StationName = stationName ?? throw new ArgumentNullException(nameof(stationName));
        TrackNumber = trackNumber ?? throw new ArgumentNullException(nameof(trackNumber));
        CircuitIds = circuitIds ?? throw new ArgumentNullException(nameof(circuitIds));
    }

    /// <summary>
    /// 指定された軌道回路IDがこの番線に該当するか判定
    /// </summary>
    public bool ContainsCircuit(string circuitId)
    {
        return CircuitIds.Contains(circuitId);
    }

    /// <summary>
    /// 駅・番線の識別キーを取得（例: "館浜_1"）
    /// </summary>
    public string GetKey()
    {
        return $"{StationName}_{TrackNumber}";
    }
}
```

#### 3.1.2 GameState

**責務**: Traincrewゲームの現在状態を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// ゲーム状態
/// </summary>
public class GameState
{
    /// <summary>
    /// ゲーム画面種別
    /// </summary>
    public GameScreen Screen { get; init; }

    /// <summary>
    /// 一時停止中かどうか
    /// </summary>
    public bool IsPaused { get; init; }

    /// <summary>
    /// 乗務員種別
    /// </summary>
    public CrewType CrewType { get; init; }

    /// <summary>
    /// 列車状態
    /// </summary>
    public TrainState? TrainState { get; init; }

    /// <summary>
    /// 信号情報
    /// </summary>
    public SignalInfo? SignalInfo { get; init; }

    /// <summary>
    /// 現在在線している軌道回路IDのリスト
    /// </summary>
    public List<string> CurrentCircuitId { get; init; } = [];

    /// <summary>
    /// ゲーム内の現在時刻（ポーズに追従するため）
    /// </summary>
    public DateTime CurrentGameTime { get; init; }

    /// <summary>
    /// プレイ中かどうか
    /// </summary>
    public bool IsPlaying => Screen == GameScreen.Driving || Screen == GameScreen.Conducting;

    /// <summary>
    /// 駅に在線しているかどうか（軌道回路が駅ホームトラックか）
    /// </summary>
    public bool IsAtStation { get; init; }
}

/// <summary>
/// ゲーム画面種別
/// </summary>
public enum GameScreen
{
    Menu,
    Driving,
    Conducting,
    Other
}

/// <summary>
/// 乗務員種別
/// </summary>
public enum CrewType
{
    None,           // 非乗務
    Driver,         // 運転士（車掌同乗）
    DriverOnly,     // 運転士ワンマン
    Conductor       // 車掌
}
```

#### 3.1.3 TrainState

**責務**: 列車の状態を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// 列車状態
/// </summary>
public class TrainState
{
    /// <summary>
    /// 速度 (km/h)
    /// </summary>
    public double Speed { get; init; }

    /// <summary>
    /// ドアが開いているか
    /// </summary>
    public bool IsDoorsOpen { get; init; }

    /// <summary>
    /// 列車番号（例: "1206A"）
    /// </summary>
    public string? TrainNumber { get; init; }

    /// <summary>
    /// 車両形式（例: "50000"）
    /// </summary>
    public string? VehicleType { get; init; }

    /// <summary>
    /// 発車時刻（ダイヤ上の予定時刻）
    /// </summary>
    public DateTime? DepartureTime { get; init; }

    /// <summary>
    /// 到着時刻
    /// </summary>
    public DateTime? ArrivalTime { get; init; }

    /// <summary>
    /// 停車中かどうか
    /// </summary>
    public bool IsStopped => Speed < 0.1;

    /// <summary>
    /// 上り列車かどうかを判定（列車番号の末尾で判断）
    /// </summary>
    public bool IsInbound()
    {
        if (string.IsNullOrEmpty(TrainNumber)) return false;

        // 列車番号の末尾が偶数なら上り、奇数なら下り
        char lastChar = TrainNumber[^1];
        if (char.IsDigit(lastChar))
        {
            return int.Parse(lastChar.ToString()) % 2 == 0;
        }
        return false;
    }

    /// <summary>
    /// 特急型車両かどうか
    /// </summary>
    public bool IsLimitedExpressType()
    {
        return VehicleType?.StartsWith("50000") ?? false;
    }
}
```

#### 3.1.4 SignalInfo

**責務**: 信号情報を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// 信号情報
/// </summary>
public class SignalInfo
{
    /// <summary>
    /// 信号現示
    /// </summary>
    public SignalAspect Aspect { get; init; }

    /// <summary>
    /// 信号が開通しているか
    /// </summary>
    public bool IsOpen => Aspect != SignalAspect.Stop;

    /// <summary>
    /// 信号が開通した時刻（状態遷移検知用）
    /// </summary>
    public DateTime? OpenedAt { get; init; }
}

/// <summary>
/// 信号現示
/// </summary>
public enum SignalAspect
{
    Stop,       // 停止
    Proceed     // 進行（進行を指示する全ての現示を含む）
}
```

#### 3.1.5 MelodyState

**責務**: メロディー再生の状態を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// メロディー再生状態
/// </summary>
public class MelodyState
{
    /// <summary>
    /// 再生中かどうか
    /// </summary>
    public bool IsPlaying { get; init; }

    /// <summary>
    /// 現在再生中のメロディーファイルパス
    /// </summary>
    public string? CurrentMelodyPath { get; init; }

    /// <summary>
    /// 現在の駅・番線情報
    /// </summary>
    public TrackInfo? CurrentTrack { get; init; }

    /// <summary>
    /// メロディー開始時刻
    /// </summary>
    public DateTime? StartedAt { get; init; }

    /// <summary>
    /// ドア閉め案内を再生済みか
    /// </summary>
    public bool DoorCloseAnnouncementPlayed { get; init; }

    /// <summary>
    /// 新しい状態を生成（イミュータブル更新）
    /// </summary>
    public MelodyState With(
        bool? isPlaying = null,
        string? currentMelodyPath = null,
        TrackInfo? currentTrack = null,
        DateTime? startedAt = null,
        bool? doorCloseAnnouncementPlayed = null)
    {
        return new MelodyState
        {
            IsPlaying = isPlaying ?? IsPlaying,
            CurrentMelodyPath = currentMelodyPath ?? CurrentMelodyPath,
            CurrentTrack = currentTrack ?? CurrentTrack,
            StartedAt = startedAt ?? StartedAt,
            DoorCloseAnnouncementPlayed = doorCloseAnnouncementPlayed ?? DoorCloseAnnouncementPlayed
        };
    }
}
```

#### 3.1.6 AutoModeConfig

**責務**: 自動モードの設定と状態を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// 自動モード設定
/// </summary>
public class AutoModeConfig
{
    /// <summary>
    /// 自動モードが有効か
    /// </summary>
    public bool IsEnabled { get; init; }

    /// <summary>
    /// 到着後の待機時間（秒）
    /// </summary>
    public double DelayAfterArrival { get; init; } = 1.0;

    /// <summary>
    /// 信号開通後の待機時間（秒）
    /// </summary>
    public double DelayAfterSignalOpen { get; init; } = 0.5;

    /// <summary>
    /// メロディーON後の最低待機時間（秒）
    /// </summary>
    public double MinimumMelodyDuration { get; init; } = 1.0;

    /// <summary>
    /// ドア開後の最低待機時間（秒）
    /// </summary>
    public double MinimumDoorOpenDuration { get; init; } = 12.0;

    /// <summary>
    /// ドア閉め案内の再生時間（秒）
    /// </summary>
    public double DoorCloseAnnouncementDuration { get; init; } = 3.0;

    /// <summary>
    /// 通常車両のマージン（秒）
    /// </summary>
    public double StandardMargin { get; init; } = 8.5;

    /// <summary>
    /// 50000系のマージン（秒）
    /// </summary>
    public double Series50000Margin { get; init; } = 16.5;

    /// <summary>
    /// 車両形式に応じたマージンを取得
    /// </summary>
    public double GetMarginForVehicle(TrainState trainState)
    {
        return trainState.IsLimitedExpressType() ? Series50000Margin : StandardMargin;
    }
}
```

#### 3.1.7 AudioProfile

**責務**: 駅・番線ごとの音声ファイルパスを保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// 音声プロファイル（駅・番線ごとの音声設定）
/// </summary>
public class AudioProfile
{
    /// <summary>
    /// 駅名
    /// </summary>
    public string StationName { get; init; }

    /// <summary>
    /// 番線
    /// </summary>
    public string TrackNumber { get; init; }

    /// <summary>
    /// 発車メロディーファイルパス
    /// </summary>
    public string MelodyFilePath { get; init; }

    /// <summary>
    /// ドア閉め案内ファイルパス（下り）
    /// </summary>
    public string? DoorCloseAnnouncementDownFilePath { get; init; }

    /// <summary>
    /// ドア閉め案内ファイルパス（上り）
    /// </summary>
    public string? DoorCloseAnnouncementUpFilePath { get; init; }

    /// <summary>
    /// コンストラクタ
    /// </summary>
    public AudioProfile(
        string stationName,
        string trackNumber,
        string melodyFilePath,
        string? doorCloseAnnouncementDownFilePath = null,
        string? doorCloseAnnouncementUpFilePath = null)
    {
        StationName = stationName ?? throw new ArgumentNullException(nameof(stationName));
        TrackNumber = trackNumber ?? throw new ArgumentNullException(nameof(trackNumber));
        MelodyFilePath = melodyFilePath ?? throw new ArgumentNullException(nameof(melodyFilePath));
        DoorCloseAnnouncementDownFilePath = doorCloseAnnouncementDownFilePath;
        DoorCloseAnnouncementUpFilePath = doorCloseAnnouncementUpFilePath;
    }

    /// <summary>
    /// 識別キーを取得（駅名_番線）
    /// </summary>
    public string GetKey()
    {
        return $"{StationName}_{TrackNumber}";
    }

    /// <summary>
    /// 指定方向のドア閉め案内ファイルパスを取得
    /// </summary>
    public string? GetDoorCloseAnnouncementPath(bool isInbound)
    {
        return isInbound ? DoorCloseAnnouncementUpFilePath : DoorCloseAnnouncementDownFilePath;
    }
}
```

#### 3.1.8 AppConfiguration

**責務**: アプリケーション全体の設定を保持する

```csharp
namespace Traincrew_depMelody.Domain.Models;

/// <summary>
/// アプリケーション設定
/// </summary>
public class AppConfiguration
{
    /// <summary>
    /// FFmpegの実行ファイルパス
    /// </summary>
    public string FFmpegPath { get; set; } = @"C:\ffmpeg\bin\ffmpeg.exe";

    /// <summary>
    /// 音声ファイルのベースディレクトリ
    /// </summary>
    public string AudioBaseDirectory { get; set; } = @".\Audio";

    /// <summary>
    /// メロディーフォルダパス
    /// </summary>
    public string MelodyDirectory => Path.Combine(AudioBaseDirectory, "Melody");

    /// <summary>
    /// 案内音声フォルダパス
    /// </summary>
    public string AnnouncementDirectory => Path.Combine(AudioBaseDirectory, "Announcement");

    /// <summary>
    /// stations.csvのパス
    /// </summary>
    public string StationsCsvPath { get; set; } = @".\stations\stations.csv";

    /// <summary>
    /// プロファイルディレクトリのパス
    /// </summary>
    public string ProfilesDirectory { get; set; } = @".\profiles";

    /// <summary>
    /// 使用するプロファイル名（拡張子なし）
    /// </summary>
    public string CurrentProfileName { get; set; } = "default";

    /// <summary>
    /// WebSocketポート番号
    /// </summary>
    public int WebSocketPort { get; set; } = 50300;

    /// <summary>
    /// ゲーム状態ポーリング間隔（ミリ秒）
    /// </summary>
    public int GameStatePollingIntervalMs { get; set; } = 16;

    /// <summary>
    /// デフォルトメロディーファイル名
    /// </summary>
    public string DefaultMelodyFileName { get; set; } = "default.mp3";

    /// <summary>
    /// ログ出力ディレクトリ
    /// </summary>
    public string LogDirectory { get; set; } = @".\Logs";

    /// <summary>
    /// 開発者モード（デバッグ情報表示）
    /// </summary>
    public bool DeveloperMode { get; set; } = false;
}
```

### 3.2 Interfaces

#### 3.2.1 Repositories

##### IAudioProfileRepository

```csharp
namespace Traincrew_depMelody.Domain.Interfaces.Repositories;

/// <summary>
/// 音声プロファイルリポジトリのインターフェース
/// </summary>
public interface IAudioProfileRepository
{
    /// <summary>
    /// 全ての音声プロファイルを取得
    /// </summary>
    Task<IEnumerable<AudioProfile>> GetAllProfilesAsync();

    /// <summary>
    /// 駅名と番線から音声プロファイルを検索
    /// </summary>
    Task<AudioProfile?> FindProfileAsync(string stationName, string trackNumber);

    /// <summary>
    /// 音声プロファイルCSVを再読み込み
    /// </summary>
    Task ReloadAsync();
}
```

##### ITrackRepository

```csharp
namespace Traincrew_depMelody.Domain.Interfaces.Repositories;

/// <summary>
/// 駅・番線情報リポジトリのインターフェース
/// </summary>
public interface ITrackRepository
{
    /// <summary>
    /// 全ての駅・番線情報を取得
    /// </summary>
    Task<IEnumerable<TrackInfo>> GetAllTracksAsync();

    /// <summary>
    /// 軌道回路IDから駅・番線情報を検索
    /// </summary>
    /// <param name="circuitId">軌道回路ID</param>
    /// <returns>該当する駅・番線情報、見つからない場合はnull</returns>
    Task<TrackInfo?> FindTrackByCircuitIdAsync(string circuitId);

    /// <summary>
    /// 駅名と番線から駅・番線情報を検索
    /// </summary>
    Task<TrackInfo?> FindTrackByStationAndNumberAsync(string stationName, string trackNumber);

    /// <summary>
    /// CSVを再読み込み（キャッシュクリア）
    /// </summary>
    Task ReloadAsync();
}
```

#### 3.2.2 Services

##### ITraincrewGameService

```csharp
namespace Traincrew_depMelody.Domain.Interfaces.Services;

/// <summary>
/// Traincrewゲーム連携サービスのインターフェース
/// </summary>
public interface ITraincrewGameService
{
    /// <summary>
    /// ゲームに接続
    /// </summary>
    Task ConnectAsync();

    /// <summary>
    /// ゲームから切断
    /// </summary>
    Task DisconnectAsync();

    /// <summary>
    /// 接続中かどうか
    /// </summary>
    bool IsConnected { get; }

    /// <summary>
    /// 現在のゲーム状態を取得
    /// </summary>
    Task<GameState> GetCurrentGameStateAsync();

    /// <summary>
    /// ゲーム状態が変化したときのイベント
    /// </summary>
    event EventHandler<GameState>? GameStateChanged;
}
```

##### IFFmpegService

```csharp
namespace Traincrew_depMelody.Domain.Interfaces.Services;

/// <summary>
/// FFmpegサービスのインターフェース
/// </summary>
public interface IFFmpegService
{
    /// <summary>
    /// 音声ファイルの長さ（秒）を取得
    /// </summary>
    /// <param name="filePath">音声ファイルパス</param>
    /// <returns>音声の長さ（秒）、取得失敗時はnull</returns>
    Task<double?> GetAudioDurationAsync(string filePath);
}
```

##### IAudioPlayerService

```csharp
namespace Traincrew_depMelody.Domain.Interfaces.Services;

/// <summary>
/// 音声再生サービスのインターフェース
/// </summary>
public interface IAudioPlayerService
{
    /// <summary>
    /// 音声をループ再生
    /// </summary>
    Task PlayLoopAsync(string filePath);

    /// <summary>
    /// 音声を1回だけ再生
    /// </summary>
    Task PlayOnceAsync(string filePath);

    /// <summary>
    /// 再生を停止
    /// </summary>
    void Stop();

    /// <summary>
    /// 一時停止
    /// </summary>
    void Pause();

    /// <summary>
    /// 一時停止から再開
    /// </summary>
    void Resume();

    /// <summary>
    /// 再生中かどうか
    /// </summary>
    bool IsPlaying { get; }

    /// <summary>
    /// 音量（0.0 ～ 1.0）
    /// </summary>
    double Volume { get; set; }
}
```

#### 3.2.3 Application Services

##### IMelodyControlService

```csharp
namespace Traincrew_depMelody.Domain.Interfaces;

/// <summary>
/// メロディー制御サービスのインターフェース
/// </summary>
public interface IMelodyControlService
{
    /// <summary>
    /// メロディー再生を開始
    /// </summary>
    Task StartMelodyAsync();

    /// <summary>
    /// メロディーを停止し、ドア閉め案内を再生
    /// </summary>
    Task StopMelodyAsync();

    /// <summary>
    /// 現在のメロディー状態を取得
    /// </summary>
    MelodyState GetCurrentState();

    /// <summary>
    /// UI操作が有効かどうか（駅に在線しているか、一時停止中でないか）
    /// </summary>
    Task<bool> IsUiEnabledAsync();

    /// <summary>
    /// メロディー状態が変化したときのイベント
    /// </summary>
    event EventHandler<MelodyState>? StateChanged;
}
```

##### IAutoModeService

```csharp
namespace Traincrew_depMelody.Domain.Interfaces;

/// <summary>
/// 自動モードサービスのインターフェース
/// </summary>
public interface IAutoModeService
{
    /// <summary>
    /// 自動モードを開始
    /// </summary>
    Task StartAsync();

    /// <summary>
    /// 自動モードを停止
    /// </summary>
    Task StopAsync();

    /// <summary>
    /// 自動モードが有効かどうか
    /// </summary>
    bool IsEnabled { get; }

    /// <summary>
    /// 自動モード設定を取得
    /// </summary>
    AutoModeConfig GetConfig();

    /// <summary>
    /// 自動モード設定を更新
    /// </summary>
    void UpdateConfig(AutoModeConfig config);
}
```

##### IAudioPlaybackService

```csharp
namespace Traincrew_depMelody.Domain.Interfaces;

/// <summary>
/// 音声再生統合サービスのインターフェース
/// </summary>
public interface IAudioPlaybackService
{
    /// <summary>
    /// メロディーを再生（ループ）
    /// </summary>
    Task PlayMelodyAsync(TrackInfo track);

    /// <summary>
    /// メロディーを停止
    /// </summary>
    void StopMelody();

    /// <summary>
    /// ドア閉め案内を再生（1回）
    /// </summary>
    Task PlayDoorCloseAnnouncementAsync(TrackInfo track, bool isInbound);

    /// <summary>
    /// 全ての音声を一時停止
    /// </summary>
    void PauseAll();

    /// <summary>
    /// 一時停止から再開
    /// </summary>
    void ResumeAll();

    /// <summary>
    /// メロディーの長さを取得（秒）
    /// </summary>
    Task<double> GetMelodyDurationAsync(TrackInfo track);
}
```

## 4. Application Layer（アプリケーション層）

### 4.1 Services

#### 4.1.1 MelodyControlService

**責務**: メロディー制御の中核ロジックを実装する

```csharp
namespace Traincrew_depMelody.Application.Services;

public class MelodyControlService : IMelodyControlService
{
    private readonly ITraincrewGameService _gameService;
    private readonly ITrackRepository _trackRepository;
    private readonly IAudioPlaybackService _audioPlayback;
    private readonly ILogger<MelodyControlService> _logger;

    private MelodyState _currentState = new MelodyState { IsPlaying = false };
    private readonly object _stateLock = new object();

    public event EventHandler<MelodyState>? StateChanged;

    public MelodyControlService(
        ITraincrewGameService gameService,
        ITrackRepository trackRepository,
        IAudioPlaybackService audioPlayback,
        ILogger<MelodyControlService> logger)
    {
        _gameService = gameService ?? throw new ArgumentNullException(nameof(gameService));
        _trackRepository = trackRepository ?? throw new ArgumentNullException(nameof(trackRepository));
        _audioPlayback = audioPlayback ?? throw new ArgumentNullException(nameof(audioPlayback));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        // ゲーム状態変化時のイベントハンドリング
        _gameService.GameStateChanged += OnGameStateChanged;
    }

    /// <summary>
    /// メロディー再生を開始
    /// </summary>
    public async Task StartMelodyAsync()
    {
        lock (_stateLock)
        {
            if (_currentState.IsPlaying)
            {
                _logger.LogDebug("メロディーは既に再生中です");
                return;
            }
        }

        // ゲーム状態を取得
        var gameState = await _gameService.GetCurrentGameStateAsync();

        if (!gameState.IsAtStation || !gameState.CurrentCircuitId.Any())
        {
            _logger.LogWarning("駅に在線していません");
            return;
        }

        // 軌道回路から駅・番線を特定（複数ある場合は最初の軌道回路を使用）
        var track = await _trackRepository.FindTrackByCircuitIdAsync(gameState.CurrentCircuitId.First());
        if (track == null)
        {
            _logger.LogWarning($"軌道回路ID '{gameState.CurrentCircuitId.First()}' に対応する駅・番線が見つかりません");
            return;
        }

        _logger.LogInformation($"メロディー再生開始: {track.StationName} {track.TrackNumber}番線");

        // メロディー再生
        await _audioPlayback.PlayMelodyAsync(track);

        // 状態更新
        var currentGameState = await _gameService.GetCurrentGameStateAsync();
        lock (_stateLock)
        {
            _currentState = _currentState.With(
                isPlaying: true,
                currentTrack: track,
                startedAt: currentGameState.CurrentGameTime,
                doorCloseAnnouncementPlayed: false
            );
        }

        StateChanged?.Invoke(this, _currentState);
    }

    /// <summary>
    /// メロディーを停止し、ドア閉め案内を再生
    /// </summary>
    public async Task StopMelodyAsync()
    {
        TrackInfo? track;
        lock (_stateLock)
        {
            if (!_currentState.IsPlaying)
            {
                _logger.LogDebug("メロディーは再生されていません");
                return;
            }

            track = _currentState.CurrentTrack;
        }

        if (track == null)
        {
            _logger.LogWarning("現在の駅・番線情報がありません");
            return;
        }

        _logger.LogInformation($"メロディー停止: {track.StationName} {track.TrackNumber}番線");

        // メロディー停止
        _audioPlayback.StopMelody();

        // 状態更新
        lock (_stateLock)
        {
            _currentState = _currentState.With(isPlaying: false);
        }

        StateChanged?.Invoke(this, _currentState);

        // ゲーム時刻で1秒待機
        var gameState = await _gameService.GetCurrentGameStateAsync();
        DateTime startTime = gameState.CurrentGameTime;
        DateTime targetTime = startTime.AddSeconds(1.0);

        while (true)
        {
            gameState = await _gameService.GetCurrentGameStateAsync();

            // ゲーム時刻が目標時刻に到達したら終了
            if (gameState.CurrentGameTime >= targetTime)
            {
                break;
            }

            await Task.Delay(16); // 16ms周期でチェック
        }

        // ドア閉め案内再生
        gameState = await _gameService.GetCurrentGameStateAsync();
        bool isInbound = gameState.TrainState?.IsInbound() ?? false;

        _logger.LogInformation($"ドア閉め案内再生: {track.TrackNumber}番線 ({(isInbound ? "上り" : "下り")})");
        await _audioPlayback.PlayDoorCloseAnnouncementAsync(track, isInbound);

        // 案内再生済みフラグ
        lock (_stateLock)
        {
            _currentState = _currentState.With(doorCloseAnnouncementPlayed: true);
        }

        StateChanged?.Invoke(this, _currentState);
    }

    /// <summary>
    /// 現在のメロディー状態を取得
    /// </summary>
    public MelodyState GetCurrentState()
    {
        lock (_stateLock)
        {
            return _currentState;
        }
    }

    /// <summary>
    /// UI操作が有効かどうか
    /// </summary>
    public async Task<bool> IsUiEnabledAsync()
    {
        var gameState = await _gameService.GetCurrentGameStateAsync();
        return gameState.IsAtStation && !gameState.IsPaused;
    }

    /// <summary>
    /// ゲーム状態が変化したときの処理
    /// </summary>
    private void OnGameStateChanged(object? sender, GameState gameState)
    {
        // 一時停止状態の処理
        if (gameState.IsPaused)
        {
            _audioPlayback.PauseAll();
        }
        else
        {
            _audioPlayback.ResumeAll();
        }

        // 駅から離れた場合、メロディーを停止
        if (!gameState.IsAtStation)
        {
            lock (_stateLock)
            {
                if (_currentState.IsPlaying)
                {
                    _logger.LogInformation("駅から離れたため、メロディーを停止します");
                    _audioPlayback.StopMelody();
                    _currentState = _currentState.With(isPlaying: false);
                    StateChanged?.Invoke(this, _currentState);
                }
            }
        }
    }
}
```

#### 4.1.2 AutoModeService

**責務**: 自動モードの制御ロジックを実装する

```csharp
namespace Traincrew_depMelody.Application.Services;

public class AutoModeService : IAutoModeService
{
    private readonly ITraincrewGameService _gameService;
    private readonly IMelodyControlService _melodyControl;
    private readonly IAudioPlaybackService _audioPlayback;
    private readonly ITrackRepository _trackRepository;
    private readonly ILogger<AutoModeService> _logger;

    private Timer? _checkTimer;
    private AutoModeConfig _config = new AutoModeConfig { IsEnabled = false };
    private readonly object _configLock = new object();

    // 自動モードの状態追跡（ゲーム内時刻で記録）
    private DateTime? _arrivalTime;
    private DateTime? _signalOpenTime;
    private DateTime? _melodyStartTime;
    private DateTime? _doorOpenTime;
    private bool _melodyTriggered;

    public bool IsEnabled
    {
        get
        {
            lock (_configLock)
            {
                return _config.IsEnabled;
            }
        }
    }

    public AutoModeService(
        ITraincrewGameService gameService,
        IMelodyControlService melodyControl,
        IAudioPlaybackService audioPlayback,
        ITrackRepository trackRepository,
        ILogger<AutoModeService> logger)
    {
        _gameService = gameService ?? throw new ArgumentNullException(nameof(gameService));
        _melodyControl = melodyControl ?? throw new ArgumentNullException(nameof(melodyControl));
        _audioPlayback = audioPlayback ?? throw new ArgumentNullException(nameof(audioPlayback));
        _trackRepository = trackRepository ?? throw new ArgumentNullException(nameof(trackRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// 自動モードを開始
    /// </summary>
    public async Task StartAsync()
    {
        lock (_configLock)
        {
            _config = _config with { IsEnabled = true };
        }

        _logger.LogInformation("自動モード開始");

        // 16ミリ秒周期でチェック
        _checkTimer = new Timer(async _ => await CheckAndExecuteAsync(), null, 0, 16);

        await Task.CompletedTask;
    }

    /// <summary>
    /// 自動モードを停止
    /// </summary>
    public async Task StopAsync()
    {
        lock (_configLock)
        {
            _config = _config with { IsEnabled = false };
        }

        _checkTimer?.Dispose();
        _checkTimer = null;

        _logger.LogInformation("自動モード停止");

        await Task.CompletedTask;
    }

    /// <summary>
    /// 自動モード設定を取得
    /// </summary>
    public AutoModeConfig GetConfig()
    {
        lock (_configLock)
        {
            return _config;
        }
    }

    /// <summary>
    /// 自動モード設定を更新
    /// </summary>
    public void UpdateConfig(AutoModeConfig config)
    {
        lock (_configLock)
        {
            _config = config;
        }
    }

    /// <summary>
    /// 自動モードの条件チェックと実行
    /// </summary>
    private async Task CheckAndExecuteAsync()
    {
        if (!IsEnabled) return;

        try
        {
            var gameState = await _gameService.GetCurrentGameStateAsync();

            // 運転士モード時のみ自動モード有効
            if (gameState.CrewType != CrewType.Driver) return;

            // 一時停止中は何もしない
            if (gameState.IsPaused) return;

            // 駅に在線していない場合はリセット
            if (!gameState.IsAtStation)
            {
                ResetState();
                return;
            }

            var trainState = gameState.TrainState;
            if (trainState == null) return;

            // 到着時刻を記録（ゲーム内時刻）
            if (trainState.IsStopped && _arrivalTime == null)
            {
                _arrivalTime = gameState.CurrentGameTime;
                _logger.LogDebug("到着を検知");
            }

            // 信号開通時刻を記録（ゲーム内時刻）
            if (gameState.SignalInfo?.IsOpen == true && _signalOpenTime == null)
            {
                _signalOpenTime = gameState.CurrentGameTime;
                _logger.LogDebug("信号開通を検知");
            }

            // ドア開時刻を記録（ゲーム内時刻）
            if (trainState.IsDoorsOpen && _doorOpenTime == null)
            {
                _doorOpenTime = gameState.CurrentGameTime;
                _logger.LogDebug("ドア開を検知");
            }

            // メロディーON条件チェック
            await CheckMelodyOnConditionsAsync(gameState, trainState);

            // メロディーOFF条件チェック
            await CheckMelodyOffConditionsAsync(gameState, trainState);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "自動モードチェック中にエラーが発生");
        }
    }

    /// <summary>
    /// メロディーON条件をチェック
    /// </summary>
    private async Task CheckMelodyOnConditionsAsync(GameState gameState, TrainState trainState)
    {
        if (_melodyTriggered) return;

        var config = GetConfig();
        var now = gameState.CurrentGameTime; // ゲーム内時刻を使用

        bool shouldStart = false;

        // 条件1: 到着後1秒後
        if (_arrivalTime != null && (now - _arrivalTime.Value).TotalSeconds >= config.DelayAfterArrival)
        {
            shouldStart = true;
            _logger.LogDebug("条件1満たす: 到着後1秒");
        }

        // 条件2: 信号開通0.5秒後
        if (_signalOpenTime != null && (now - _signalOpenTime.Value).TotalSeconds >= config.DelayAfterSignalOpen)
        {
            shouldStart = true;
            _logger.LogDebug("条件2満たす: 信号開通0.5秒後");
        }

        // 条件3: 発車時刻ベース
        if (trainState.DepartureTime != null && gameState.CurrentCircuitId.Any())
        {
            var track = await _trackRepository.FindTrackByCircuitIdAsync(gameState.CurrentCircuitId.First());
            if (track != null)
            {
                double melodyDuration = await _audioPlayback.GetMelodyDurationAsync(track);
                double margin = config.GetMarginForVehicle(trainState);
                double totalOffset = melodyDuration + config.DoorCloseAnnouncementDuration + margin;

                var targetTime = trainState.DepartureTime.Value.AddSeconds(-totalOffset);

                if (now >= targetTime)
                {
                    shouldStart = true;
                    _logger.LogDebug($"条件3満たす: 発車時刻ベース (発車予定: {trainState.DepartureTime:HH:mm:ss})");
                }
            }
        }

        if (shouldStart)
        {
            _logger.LogInformation("自動モード: メロディー開始");
            await _melodyControl.StartMelodyAsync();
            _melodyStartTime = gameState.CurrentGameTime; // ゲーム内時刻を使用
            _melodyTriggered = true;
        }
    }

    /// <summary>
    /// メロディーOFF条件をチェック
    /// </summary>
    private async Task CheckMelodyOffConditionsAsync(GameState gameState, TrainState trainState)
    {
        if (!_melodyTriggered) return;

        var melodyState = _melodyControl.GetCurrentState();
        if (!melodyState.IsPlaying) return;

        var config = GetConfig();
        var now = gameState.CurrentGameTime; // ゲーム内時刻を使用

        bool shouldStop = false;

        // 条件1: ON後最低1秒後
        if (_melodyStartTime != null && (now - _melodyStartTime.Value).TotalSeconds < config.MinimumMelodyDuration)
        {
            return;
        }

        // 条件2: ドア開後最低12秒後
        if (_doorOpenTime != null && (now - _doorOpenTime.Value).TotalSeconds < config.MinimumDoorOpenDuration)
        {
            return;
        }

        // 条件3: 発車時刻ベース
        if (trainState.DepartureTime != null)
        {
            double margin = config.GetMarginForVehicle(trainState);
            double totalOffset = config.DoorCloseAnnouncementDuration + margin;

            var targetTime = trainState.DepartureTime.Value.AddSeconds(-totalOffset);

            if (now >= targetTime)
            {
                shouldStop = true;
                _logger.LogDebug($"条件3満たす: 発車時刻ベース停止 (発車予定: {trainState.DepartureTime:HH:mm:ss})");
            }
        }

        if (shouldStop)
        {
            _logger.LogInformation("自動モード: メロディー停止");
            await _melodyControl.StopMelodyAsync();
        }
    }

    /// <summary>
    /// 状態をリセット
    /// </summary>
    private void ResetState()
    {
        _arrivalTime = null;
        _signalOpenTime = null;
        _melodyStartTime = null;
        _doorOpenTime = null;
        _melodyTriggered = false;
    }
}
```

#### 4.1.3 AudioPlaybackService

**責務**: 音声再生の統合制御を実装する

```csharp
namespace Traincrew_depMelody.Application.Services;

public class AudioPlaybackService : IAudioPlaybackService
{
    private readonly IAudioPlayerService _melodyPlayer;
    private readonly IAudioPlayerService _announcementPlayer;
    private readonly IFFmpegService _ffmpegService;
    private readonly IAudioProfileRepository _audioProfileRepository;
    private readonly AppConfiguration _config;
    private readonly ILogger<AudioPlaybackService> _logger;

    public AudioPlaybackService(
        IAudioPlayerService melodyPlayer,
        IAudioPlayerService announcementPlayer,
        IFFmpegService ffmpegService,
        IAudioProfileRepository audioProfileRepository,
        AppConfiguration config,
        ILogger<AudioPlaybackService> logger)
    {
        _melodyPlayer = melodyPlayer ?? throw new ArgumentNullException(nameof(melodyPlayer));
        _announcementPlayer = announcementPlayer ?? throw new ArgumentNullException(nameof(announcementPlayer));
        _ffmpegService = ffmpegService ?? throw new ArgumentNullException(nameof(ffmpegService));
        _audioProfileRepository = audioProfileRepository ?? throw new ArgumentNullException(nameof(audioProfileRepository));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// メロディーを再生（ループ）
    /// </summary>
    public async Task PlayMelodyAsync(TrackInfo track)
    {
        // 音声プロファイルから実際のファイルパスを取得
        var profile = await _audioProfileRepository.FindProfileAsync(track.StationName, track.TrackNumber);

        if (profile == null)
        {
            _logger.LogWarning($"音声プロファイルが見つかりません: {track.StationName} {track.TrackNumber}番線、デフォルトを使用");
            await _melodyPlayer.PlayLoopAsync(GetDefaultMelodyPath());
            return;
        }

        string melodyPath = profile.MelodyFilePath;

        if (!File.Exists(melodyPath))
        {
            _logger.LogWarning($"メロディーファイルが見つかりません: {melodyPath}、デフォルトを使用");
            melodyPath = GetDefaultMelodyPath();

            if (!File.Exists(melodyPath))
            {
                _logger.LogError("デフォルトメロディーも見つかりません");
                throw new FileNotFoundException("メロディーファイルが見つかりません", melodyPath);
            }
        }

        await _melodyPlayer.PlayLoopAsync(melodyPath);
    }

    /// <summary>
    /// メロディーを停止
    /// </summary>
    public void StopMelody()
    {
        _melodyPlayer.Stop();
    }

    /// <summary>
    /// ドア閉め案内を再生（1回）
    /// </summary>
    public async Task PlayDoorCloseAnnouncementAsync(TrackInfo track, bool isInbound)
    {
        // 音声プロファイルから実際のファイルパスを取得
        var profile = await _audioProfileRepository.FindProfileAsync(track.StationName, track.TrackNumber);

        if (profile == null)
        {
            _logger.LogWarning($"音声プロファイルが見つかりません: {track.StationName} {track.TrackNumber}番線");
            return;
        }

        string? announcementPath = profile.GetDoorCloseAnnouncementPath(isInbound);

        if (string.IsNullOrEmpty(announcementPath))
        {
            _logger.LogWarning($"ドア閉め案内ファイルパスが設定されていません: {track.StationName} {track.TrackNumber}番線 ({(isInbound ? "上り" : "下り")})");
            return;
        }

        if (!File.Exists(announcementPath))
        {
            _logger.LogWarning($"ドア閉め案内ファイルが見つかりません: {announcementPath}");
            return;
        }

        await _announcementPlayer.PlayOnceAsync(announcementPath);
    }

    /// <summary>
    /// 全ての音声を一時停止
    /// </summary>
    public void PauseAll()
    {
        _melodyPlayer.Pause();
        _announcementPlayer.Pause();
    }

    /// <summary>
    /// 一時停止から再開
    /// </summary>
    public void ResumeAll()
    {
        _melodyPlayer.Resume();
        _announcementPlayer.Resume();
    }

    /// <summary>
    /// メロディーの長さを取得（秒）
    /// </summary>
    public async Task<double> GetMelodyDurationAsync(TrackInfo track)
    {
        // 音声プロファイルから実際のファイルパスを取得
        var profile = await _audioProfileRepository.FindProfileAsync(track.StationName, track.TrackNumber);

        string melodyPath;
        if (profile == null || !File.Exists(profile.MelodyFilePath))
        {
            melodyPath = GetDefaultMelodyPath();
        }
        else
        {
            melodyPath = profile.MelodyFilePath;
        }

        var duration = await _ffmpegService.GetAudioDurationAsync(melodyPath);
        return duration ?? 30.0; // デフォルト30秒
    }

    /// <summary>
    /// デフォルトメロディーパスを取得
    /// </summary>
    private string GetDefaultMelodyPath()
    {
        return Path.Combine(_config.AudioBaseDirectory, _config.DefaultMelodyFileName);
    }
}
```

## 5. Infrastructure Layer（インフラストラクチャ層）

### 5.1 Repositories

#### 5.1.1 AudioProfileRepository

**責務**: プロファイルCSV（例: default.csv）から音声プロファイル情報を読み込む

```csharp
namespace Traincrew_depMelody.Infrastructure.Repositories;

public class AudioProfileRepository : IAudioProfileRepository
{
    private readonly AppConfiguration _config;
    private readonly ILogger<AudioProfileRepository> _logger;
    private Dictionary<string, AudioProfile> _profiles = new Dictionary<string, AudioProfile>();
    private readonly object _cacheLock = new object();

    public AudioProfileRepository(AppConfiguration config, ILogger<AudioProfileRepository> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// 全ての音声プロファイルを取得
    /// </summary>
    public async Task<IEnumerable<AudioProfile>> GetAllProfilesAsync()
    {
        await EnsureLoadedAsync();

        lock (_cacheLock)
        {
            return _profiles.Values.ToList();
        }
    }

    /// <summary>
    /// 駅名と番線から音声プロファイルを検索
    /// </summary>
    public async Task<AudioProfile?> FindProfileAsync(string stationName, string trackNumber)
    {
        await EnsureLoadedAsync();

        string key = $"{stationName}_{trackNumber}";

        lock (_cacheLock)
        {
            return _profiles.ContainsKey(key) ? _profiles[key] : null;
        }
    }

    /// <summary>
    /// 音声プロファイルCSVを再読み込み
    /// </summary>
    public async Task ReloadAsync()
    {
        _logger.LogInformation("プロファイルCSVを再読み込み");
        await LoadCsvAsync();
    }

    /// <summary>
    /// 初回読み込み確認
    /// </summary>
    private async Task EnsureLoadedAsync()
    {
        lock (_cacheLock)
        {
            if (_profiles.Count > 0) return;
        }

        await LoadCsvAsync();
    }

    /// <summary>
    /// CSVファイルを読み込み
    /// </summary>
    private async Task LoadCsvAsync()
    {
        string csvPath = Path.Combine(_config.ProfilesDirectory, $"{_config.CurrentProfileName}.csv");

        if (!File.Exists(csvPath))
        {
            _logger.LogError($"プロファイルCSVが見つかりません: {csvPath}");
            throw new FileNotFoundException("プロファイルCSVが見つかりません", csvPath);
        }

        var profiles = new Dictionary<string, AudioProfile>();

        try
        {
            using var reader = new StreamReader(csvPath, System.Text.Encoding.UTF8);

            // ヘッダー行をスキップ
            await reader.ReadLineAsync();

            while (!reader.EndOfStream)
            {
                var line = await reader.ReadLineAsync();
                if (string.IsNullOrWhiteSpace(line)) continue;

                var values = line.Split(',');

                if (values.Length < 3)
                {
                    _logger.LogWarning($"不正なCSV行をスキップ: {line}");
                    continue;
                }

                string stationName = values[0].Trim();
                string trackNumber = values[1].Trim();
                string melodyPath = values[2].Trim();
                string? doorDownPath = values.Length > 3 ? values[3].Trim() : null;
                string? doorUpPath = values.Length > 4 ? values[4].Trim() : null;

                // 空文字列はnullに変換
                if (string.IsNullOrEmpty(doorDownPath)) doorDownPath = null;
                if (string.IsNullOrEmpty(doorUpPath)) doorUpPath = null;

                var profile = new AudioProfile(stationName, trackNumber, melodyPath, doorDownPath, doorUpPath);
                profiles[profile.GetKey()] = profile;
            }

            lock (_cacheLock)
            {
                _profiles = profiles;
            }

            _logger.LogInformation($"プロファイルCSVを読み込みました: {profiles.Count}件");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "プロファイルCSV読み込み中にエラーが発生");
            throw;
        }
    }
}
```

#### 5.1.2 TrackRepository

**責務**: stations.csvから駅・番線情報を読み込む

```csharp
namespace Traincrew_depMelody.Infrastructure.Repositories;

public class TrackRepository : ITrackRepository
{
    private readonly AppConfiguration _config;
    private readonly ILogger<TrackRepository> _logger;
    private List<TrackInfo> _tracks = new List<TrackInfo>();
    private readonly object _cacheLock = new object();

    public TrackRepository(AppConfiguration config, ILogger<TrackRepository> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// 全ての駅・番線情報を取得
    /// </summary>
    public async Task<IEnumerable<TrackInfo>> GetAllTracksAsync()
    {
        await EnsureLoadedAsync();

        lock (_cacheLock)
        {
            return _tracks.ToList();
        }
    }

    /// <summary>
    /// 軌道回路IDから駅・番線情報を検索
    /// </summary>
    public async Task<TrackInfo?> FindTrackByCircuitIdAsync(string circuitId)
    {
        await EnsureLoadedAsync();

        lock (_cacheLock)
        {
            return _tracks.FirstOrDefault(t => t.ContainsCircuit(circuitId));
        }
    }

    /// <summary>
    /// 駅名と番線から駅・番線情報を検索
    /// </summary>
    public async Task<TrackInfo?> FindTrackByStationAndNumberAsync(string stationName, string trackNumber)
    {
        await EnsureLoadedAsync();

        lock (_cacheLock)
        {
            return _tracks.FirstOrDefault(t =>
                t.StationName == stationName && t.TrackNumber == trackNumber);
        }
    }

    /// <summary>
    /// CSVを再読み込み
    /// </summary>
    public async Task ReloadAsync()
    {
        _logger.LogInformation("stations.csvを再読み込み");
        await LoadCsvAsync();
    }

    /// <summary>
    /// 初回読み込み確認
    /// </summary>
    private async Task EnsureLoadedAsync()
    {
        lock (_cacheLock)
        {
            if (_tracks.Count > 0) return;
        }

        await LoadCsvAsync();
    }

    /// <summary>
    /// CSVファイルを読み込み
    /// </summary>
    private async Task LoadCsvAsync()
    {
        string csvPath = _config.StationsCsvPath;

        if (!File.Exists(csvPath))
        {
            _logger.LogError($"stations.csvが見つかりません: {csvPath}");
            throw new FileNotFoundException("stations.csvが見つかりません", csvPath);
        }

        var tracks = new List<TrackInfo>();

        try
        {
            using var reader = new StreamReader(csvPath, System.Text.Encoding.UTF8);

            // ヘッダー行をスキップ
            await reader.ReadLineAsync();

            while (!reader.EndOfStream)
            {
                var line = await reader.ReadLineAsync();
                if (string.IsNullOrWhiteSpace(line)) continue;

                var values = line.Split(',');

                if (values.Length < 3)
                {
                    _logger.LogWarning($"不正なCSV行をスキップ: {line}");
                    continue;
                }

                string stationName = values[0].Trim();
                string trackNumber = values[1].Trim();

                var circuits = new List<string>();
                for (int i = 2; i < values.Length; i++)
                {
                    string circuit = values[i].Trim();
                    if (!string.IsNullOrEmpty(circuit))
                    {
                        circuits.Add(circuit);
                    }
                }

                var trackInfo = new TrackInfo(stationName, trackNumber, circuits);
                tracks.Add(trackInfo);
            }

            lock (_cacheLock)
            {
                _tracks = tracks;
            }

            _logger.LogInformation($"stations.csvを読み込みました: {tracks.Count}件");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "stations.csv読み込み中にエラーが発生");
            throw;
        }
    }
}
```

### 5.2 External Services

#### 5.2.1 TraincrewGameService

**責務**: Traincrewゲームとの通信を実装する

```csharp
namespace Traincrew_depMelody.Infrastructure.ExternalServices;

public class TraincrewGameService : ITraincrewGameService, IDisposable
{
    private readonly AppConfiguration _config;
    private readonly ILogger<TraincrewGameService> _logger;

    private ClientWebSocket? _webSocket;
    private bool _isConnected;
    private CancellationTokenSource? _cts;

    public bool IsConnected => _isConnected;

    public event EventHandler<GameState>? GameStateChanged;

    // TrainCrewInput.dll のメソッド定義（P/Invoke）
    [DllImport("TrainCrewInput.dll", CallingConvention = CallingConvention.Cdecl)]
    private static extern int GetGameScreen();

    [DllImport("TrainCrewInput.dll", CallingConvention = CallingConvention.Cdecl)]
    private static extern bool IsPaused();

    [DllImport("TrainCrewInput.dll", CallingConvention = CallingConvention.Cdecl)]
    private static extern int GetCrewType();

    public TraincrewGameService(AppConfiguration config, ILogger<TraincrewGameService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// ゲームに接続
    /// </summary>
    public async Task ConnectAsync()
    {
        if (_isConnected)
        {
            _logger.LogWarning("既に接続済みです");
            return;
        }

        try
        {
            _webSocket = new ClientWebSocket();
            _cts = new CancellationTokenSource();

            string uri = $"ws://localhost:{_config.WebSocketPort}";
            await _webSocket.ConnectAsync(new Uri(uri), _cts.Token);

            _isConnected = true;
            _logger.LogInformation("Traincrewゲームに接続しました");

            // 受信ループを開始
            _ = Task.Run(() => ReceiveLoopAsync(_cts.Token));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Traincrewゲームへの接続に失敗");
            throw;
        }
    }

    /// <summary>
    /// ゲームから切断
    /// </summary>
    public async Task DisconnectAsync()
    {
        if (!_isConnected) return;

        _cts?.Cancel();

        if (_webSocket != null)
        {
            await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            _webSocket.Dispose();
            _webSocket = null;
        }

        _isConnected = false;
        _logger.LogInformation("Traincrewゲームから切断しました");
    }

    /// <summary>
    /// 現在のゲーム状態を取得
    /// </summary>
    public async Task<GameState> GetCurrentGameStateAsync()
    {
        // TrainCrewInput.dllから情報を取得
        var screen = (GameScreen)GetGameScreen();
        bool isPaused = IsPaused();
        var crewType = (CrewType)GetCrewType();

        // WebSocketから軌道回路情報を取得（簡略化）
        List<string> currentCircuitIds = await GetCurrentCircuitIdsAsync();

        // TODO: TrainState, SignalInfo も同様に取得
        TrainState? trainState = null;
        SignalInfo? signalInfo = null;

        bool isAtStation = currentCircuitIds.Any(); // 簡易判定

        return new GameState
        {
            Screen = screen,
            IsPaused = isPaused,
            CrewType = crewType,
            TrainState = trainState,
            SignalInfo = signalInfo,
            CurrentCircuitId = currentCircuitIds,
            IsAtStation = isAtStation
        };
    }

    /// <summary>
    /// WebSocketから軌道回路IDリストを取得
    /// </summary>
    private async Task<List<string>> GetCurrentCircuitIdsAsync()
    {
        // TODO: 実際のWebSocket通信実装
        // 軌道回路情報を取得する処理を実装
        await Task.CompletedTask;
        return []; // プレースホルダー
    }

    /// <summary>
    /// WebSocket受信ループ
    /// </summary>
    private async Task ReceiveLoopAsync(CancellationToken cancellationToken)
    {
        var buffer = new byte[1024 * 4];

        try
        {
            while (!cancellationToken.IsCancellationRequested && _webSocket != null)
            {
                var result = await _webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), cancellationToken);

                if (result.MessageType == WebSocketMessageType.Close)
                {
                    break;
                }

                // メッセージを処理
                string message = System.Text.Encoding.UTF8.GetString(buffer, 0, result.Count);
                ProcessWebSocketMessage(message);
            }
        }
        catch (OperationCanceledException)
        {
            // 正常なキャンセル
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "WebSocket受信中にエラーが発生");
        }
    }

    /// <summary>
    /// WebSocketメッセージを処理
    /// </summary>
    private void ProcessWebSocketMessage(string message)
    {
        // TODO: JSONパース等の実装
        _logger.LogTrace($"WebSocketメッセージ受信: {message}");
    }

    public void Dispose()
    {
        DisconnectAsync().Wait();
        _cts?.Dispose();
    }
}
```

#### 5.2.2 FFmpegService

**責務**: FFmpegを使った音声解析を実装する

```csharp
namespace Traincrew_depMelody.Infrastructure.ExternalServices;

public class FFmpegService : IFFmpegService
{
    private readonly AppConfiguration _config;
    private readonly ILogger<FFmpegService> _logger;

    public FFmpegService(AppConfiguration config, ILogger<FFmpegService> logger)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// 音声ファイルの長さ（秒）を取得
    /// </summary>
    public async Task<double?> GetAudioDurationAsync(string filePath)
    {
        if (!File.Exists(filePath))
        {
            _logger.LogWarning($"音声ファイルが見つかりません: {filePath}");
            return null;
        }

        try
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = _config.FFmpegPath,
                Arguments = $"-i \"{filePath}\" -hide_banner",
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = Process.Start(startInfo);
            if (process == null)
            {
                _logger.LogError("FFmpegプロセスの起動に失敗");
                return null;
            }

            string output = await process.StandardError.ReadToEndAsync();
            await process.WaitForExitAsync();

            // "Duration: 00:00:35.50" のような行をパース
            var match = Regex.Match(output, @"Duration: (\d{2}):(\d{2}):(\d{2}\.\d{2})");

            if (match.Success)
            {
                int hours = int.Parse(match.Groups[1].Value);
                int minutes = int.Parse(match.Groups[2].Value);
                double seconds = double.Parse(match.Groups[3].Value, CultureInfo.InvariantCulture);

                double totalSeconds = hours * 3600 + minutes * 60 + seconds;

                _logger.LogDebug($"音声ファイル長: {totalSeconds}秒 ({filePath})");
                return totalSeconds;
            }

            _logger.LogWarning($"音声ファイル長の取得に失敗: {filePath}");
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"FFmpeg実行中にエラーが発生: {filePath}");
            return null;
        }
    }
}
```

### 5.3 Audio Services

#### 5.3.1 MediaPlayerService

**責務**: WPF MediaPlayerを使った音声再生を実装する

```csharp
namespace Traincrew_depMelody.Infrastructure.AudioServices;

public class MediaPlayerService : IAudioPlayerService, IDisposable
{
    private readonly MediaPlayer _player;
    private readonly ILogger<MediaPlayerService> _logger;
    private bool _isLooping;
    private string? _currentFilePath;

    public bool IsPlaying { get; private set; }

    public double Volume
    {
        get => _player.Volume;
        set => _player.Volume = Math.Clamp(value, 0.0, 1.0);
    }

    public MediaPlayerService(ILogger<MediaPlayerService> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _player = new MediaPlayer();
        _player.MediaEnded += OnMediaEnded;
    }

    /// <summary>
    /// 音声をループ再生
    /// </summary>
    public async Task PlayLoopAsync(string filePath)
    {
        if (!File.Exists(filePath))
        {
            _logger.LogError($"音声ファイルが見つかりません: {filePath}");
            throw new FileNotFoundException("音声ファイルが見つかりません", filePath);
        }

        _currentFilePath = filePath;
        _isLooping = true;

        _player.Open(new Uri(filePath, UriKind.Absolute));
        _player.Play();

        IsPlaying = true;
        _logger.LogDebug($"ループ再生開始: {filePath}");

        await Task.CompletedTask;
    }

    /// <summary>
    /// 音声を1回だけ再生
    /// </summary>
    public async Task PlayOnceAsync(string filePath)
    {
        if (!File.Exists(filePath))
        {
            _logger.LogError($"音声ファイルが見つかりません: {filePath}");
            throw new FileNotFoundException("音声ファイルが見つかりません", filePath);
        }

        _currentFilePath = filePath;
        _isLooping = false;

        _player.Open(new Uri(filePath, UriKind.Absolute));
        _player.Play();

        IsPlaying = true;
        _logger.LogDebug($"1回再生開始: {filePath}");

        await Task.CompletedTask;
    }

    /// <summary>
    /// 再生を停止
    /// </summary>
    public void Stop()
    {
        _player.Stop();
        IsPlaying = false;
        _isLooping = false;
        _logger.LogDebug("再生停止");
    }

    /// <summary>
    /// 一時停止
    /// </summary>
    public void Pause()
    {
        _player.Pause();
        _logger.LogDebug("一時停止");
    }

    /// <summary>
    /// 一時停止から再開
    /// </summary>
    public void Resume()
    {
        _player.Play();
        _logger.LogDebug("再開");
    }

    /// <summary>
    /// メディア再生終了時の処理
    /// </summary>
    private void OnMediaEnded(object? sender, EventArgs e)
    {
        if (_isLooping && _currentFilePath != null)
        {
            // ループ再生
            _player.Position = TimeSpan.Zero;
            _player.Play();
            _logger.LogTrace("ループ再生継続");
        }
        else
        {
            IsPlaying = false;
            _logger.LogDebug("再生終了");
        }
    }

    public void Dispose()
    {
        _player.MediaEnded -= OnMediaEnded;
        _player.Close();
    }
}
```

## 6. Presentation Layer（プレゼンテーション層）

### 6.1 Views

#### 6.1.1 MainWindow

**責務**: メインウィンドウのUI制御

```csharp
namespace Traincrew_depMelody.Presentation.Views;

public partial class MainWindow : Window
{
    private readonly IMelodyControlService _melodyControl;
    private readonly IAutoModeService _autoMode;
    private readonly ITraincrewGameService _gameService;
    private readonly ILogger<MainWindow> _logger;

    public MainWindow(
        IMelodyControlService melodyControl,
        IAutoModeService autoMode,
        ITraincrewGameService gameService,
        ILogger<MainWindow> logger)
    {
        InitializeComponent();

        _melodyControl = melodyControl ?? throw new ArgumentNullException(nameof(melodyControl));
        _autoMode = autoMode ?? throw new ArgumentNullException(nameof(autoMode));
        _gameService = gameService ?? throw new ArgumentNullException(nameof(gameService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        Loaded += OnLoaded;
        Closing += OnClosing;

        _melodyControl.StateChanged += OnMelodyStateChanged;
    }

    private async void OnLoaded(object sender, RoutedEventArgs e)
    {
        try
        {
            await _gameService.ConnectAsync();
            _logger.LogInformation("アプリケーション起動完了");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "起動時エラー");
            MessageBox.Show("Traincrewゲームに接続できませんでした", "エラー", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    private async void OnClosing(object? sender, CancelEventArgs e)
    {
        await _gameService.DisconnectAsync();
        await _autoMode.StopAsync();
    }

    private async void OnButton_Click(object sender, RoutedEventArgs e)
    {
        try
        {
            await _melodyControl.StartMelodyAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "メロディー開始エラー");
            MessageBox.Show($"エラー: {ex.Message}", "エラー", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    private async void OffButton_Click(object sender, RoutedEventArgs e)
    {
        try
        {
            await _melodyControl.StopMelodyAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "メロディー停止エラー");
            MessageBox.Show($"エラー: {ex.Message}", "エラー", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    private void OnMelodyStateChanged(object? sender, MelodyState state)
    {
        // UIスレッドで更新
        Dispatcher.Invoke(() =>
        {
            OnButton.IsEnabled = !state.IsPlaying && !_autoMode.IsEnabled;
            OffButton.IsEnabled = state.IsPlaying && !_autoMode.IsEnabled;
        });
    }
}
```

## 7. まとめ

本クラス設計書では、以下を定義した：

1. **Domain Layer**: ビジネスロジックとデータ構造の定義
2. **Application Layer**: ユースケース実装とサービス統合
3. **Infrastructure Layer**: 外部システム連携と技術的実装
4. **Presentation Layer**: UI制御とユーザー操作

各クラスは単一責任の原則に従い、インターフェースを介して疎結合に設計されている。
